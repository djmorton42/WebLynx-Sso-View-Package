<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" type="image/png" href="/views/lap_counter_with_leader/sso-logo.png">
    <link rel="stylesheet" href="/views/lap_counter_with_leader/styles.css">
    {{VIEW_PROPERTIES}}
  </head>
  <body>
    <div class="split-container">
      <!-- Left half: Minimum laps remaining -->
      <div class="left-half">
        <div class="minimum-laps" id="minimum-laps">-</div>
      </div>
      
      <!-- Right half: 2x5 grid of lap counters -->
      <div class="right-half">
        <div class="lap-counter-grid" id="lap-counter-grid">
          <!-- Lap counters will be populated by JavaScript -->
        </div>
      </div>
    </div>
    
    <!-- HTML5 Template for lap counter cards -->
    <template id="lap-counter-template">
      <div class="lap-counter-card">
        <div class="laps-remaining"></div>
      </div>
    </template>
    
    <script src="/views/shared/weblynx-helpers.js"></script>
    <script>
      // Configuration - now using externalized view properties
      const UPDATE_INTERVAL = VIEW_CONFIG.updateInterval;
      
      function getLaneColor(lane) {
        return VIEW_CONFIG.laneColors?.[lane] || VIEW_CONFIG.defaultLaneColor;
      }
      
      function getStrokeColor(lane) {
        // Return stroke color for the specific lane from config
        return VIEW_CONFIG.laneStrokeColors?.[lane] || VIEW_CONFIG.defaultLaneStrokeColor || '#000000';
      }
      
      function createLapCounterCard(racer, raceStatus, halfLapModeEnabled) {
        const template = document.getElementById('lap-counter-template');
        const clone = template.content.cloneNode(true);
        
        // Use delayedLapsRemaining (server handles the 5-second delay)
        const lapsElement = clone.querySelector('.laps-remaining');
        const formattedLaps = WebLynx.formatLapsDisplay(racer.delayedLapsRemaining, raceStatus, halfLapModeEnabled, racer.hasFirstCrossing);
        
        // Check if we need to add half-lap styling for the special display
        // Only show half-lap formatting if race is NOT running AND it's actually a half-lap
        const isHalfLap = (raceStatus === 0) && // Only before race starts
                         racer.delayedLapsRemaining !== null && 
                         racer.delayedLapsRemaining !== undefined && 
                         racer.delayedLapsRemaining % 1 === 0.5;
        
        if (isHalfLap) {
          // For half laps BEFORE race starts, use formatLapsDisplayHTML for special formatting
          const htmlLaps = WebLynx.formatLapsDisplayHTML(racer.delayedLapsRemaining, raceStatus, halfLapModeEnabled, racer.hasFirstCrossing);
          lapsElement.innerHTML = htmlLaps;
          lapsElement.classList.add('half-lap');
        } else {
          // Regular display - formatLapsDisplay handles showing whole numbers when running
          lapsElement.textContent = formattedLaps;
        }
        
        // Color the numbers in the lane colors (right side only)
        lapsElement.style.color = getLaneColor(racer.lane);
        lapsElement.style.textShadow = `5px 5px 0px ${getStrokeColor(racer.lane)}, -5px -5px 0px ${getStrokeColor(racer.lane)}, 5px -5px 0px ${getStrokeColor(racer.lane)}, -5px 5px 0px ${getStrokeColor(racer.lane)}`;
        
        // Apply thinner stroke to the fraction if it's a half-lap
        if (isHalfLap) {
          // Set a thinner stroke on the fraction element
          const fractionElement = clone.querySelector('.half-lap-fraction');
          if (fractionElement) {
            fractionElement.style.textShadow = `2px 2px 0px ${getStrokeColor(racer.lane)}, -2px -2px 0px ${getStrokeColor(racer.lane)}, 2px -2px 0px ${getStrokeColor(racer.lane)}, -2px 2px 0px ${getStrokeColor(racer.lane)}`;
          }
        }
        
        return clone;
      }
      
      function createLapCounterRow(racers, raceStatus, halfLapModeEnabled) {
        const row = document.createElement('div');
        row.className = 'lap-counter-row';
        
        // Add lap counter cards for each racer (handle null for empty slots)
        for (let i = 0; i < racers.length; i++) {
          const racer = racers[i];
          if (racer === null) {
            // Create empty card
            const emptyCard = document.createElement('div');
            emptyCard.className = 'lap-counter-card empty-card';
            row.appendChild(emptyCard);
          } else {
            row.appendChild(createLapCounterCard(racer, raceStatus, halfLapModeEnabled));
          }
        }
        
        return row;
      }
      
      function updateLapCounterData() {
        WebLynx.updateRaceData((data, error) => {
          if (error) {
            console.error('Error fetching lap counter data:', error);
            return;
          }
          
          // Check if lap board is disabled via key-value
          const disableLapBoard = data.keyValues && data.keyValues['disable_lap_board'] === 'true';
          
          // Update minimum laps (left side)
          const minimumLapsElement = document.getElementById('minimum-laps');
          const activeRacers = WebLynx.getActiveRacers(data.racers);
          
          // If disabled, show empty screen and return early
          if (disableLapBoard) {
            minimumLapsElement.textContent = '';
            minimumLapsElement.innerHTML = '';
            const lapCounterGrid = document.getElementById('lap-counter-grid');
            lapCounterGrid.innerHTML = '';
            return;
          }
          
          if (activeRacers.length === 0) {
            minimumLapsElement.textContent = '-';
            minimumLapsElement.innerHTML = '-';
          } else {
            // Find the lowest delayedLapsRemaining
            const lapsRemaining = activeRacers
              .map(racer => racer.delayedLapsRemaining)
              .filter(laps => laps !== null && laps !== undefined);
            
            if (lapsRemaining.length === 0) {
              minimumLapsElement.textContent = '-';
              minimumLapsElement.innerHTML = '-';
            } else {
              const minLaps = Math.min(...lapsRemaining);
              const halfLapModeEnabled = data.halfLapModeEnabled || false;
              
              // Check if minimum is a half lap
              const isHalfLap = minLaps % 1 === 0.5;
              
              if (isHalfLap) {
                // Use HTML format for half-laps
                minimumLapsElement.innerHTML = WebLynx.formatLapsDisplayHTML(minLaps, data.status, halfLapModeEnabled, false);
                minimumLapsElement.classList.add('half-lap');
                
                // Apply thinner stroke to the fraction
                const fractionElement = minimumLapsElement.querySelector('.half-lap-fraction');
                if (fractionElement) {
                  fractionElement.style.textShadow = '2px 2px 0px #000000, -2px -2px 0px #000000, 2px -2px 0px #000000, -2px 2px 0px #000000';
                }
              } else {
                minimumLapsElement.textContent = WebLynx.formatLapsDisplay(minLaps, data.status, halfLapModeEnabled, false);
                minimumLapsElement.classList.remove('half-lap');
              }
            }
          }
          
          // Update lap counter grid (right side)
          const lapCounterGrid = document.getElementById('lap-counter-grid');
          lapCounterGrid.innerHTML = '';
          
          // Set data attribute for dynamic sizing
          lapCounterGrid.setAttribute('data-racers', activeRacers.length);
          
          const halfLapModeEnabled = data.halfLapModeEnabled || false;
          
          // Always create a 2 column x 5 row grid for 2-10 racers
          if (activeRacers.length > 0) {
            // Pad racers to ensure 10 slots (2 per row, 5 rows)
            const paddedRacers = [...activeRacers];
            while (paddedRacers.length < 10) {
              paddedRacers.push(null); // null represents an empty slot
            }
            
            // Create 5 rows with 2 racers each
            for (let row = 0; row < 5; row++) {
              const rowRacers = [
                paddedRacers[row * 2],
                paddedRacers[row * 2 + 1]
              ];
              lapCounterGrid.appendChild(createLapCounterRow(rowRacers, data.status, halfLapModeEnabled));
            }
          }
        }, 'lane');
      }
      
      // Start updating
      WebLynx.startAutoUpdate(updateLapCounterData, UPDATE_INTERVAL, 'lane');
    </script>
  </body>
</html>

