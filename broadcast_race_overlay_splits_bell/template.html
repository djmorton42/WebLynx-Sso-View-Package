<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" type="image/png" href="/views/broadcast_race_overlay_splits_bell/sso-logo.png">
    <link rel="stylesheet" href="/views/broadcast_race_overlay_splits_bell/styles.css">
    {{VIEW_PROPERTIES}}
  </head>
  <body>
    <!-- Logo in top-right corner -->
    <div class="sso-logo">
      <img src="/views/broadcast_race_overlay_splits_bell/sso-logo.png" alt="SSO Logo">
    </div>
    
    <!-- Overall race time in bottom-right corner -->
    <div class="race-clock" id="race-clock">00:00.0</div>
    
    <!-- Bell Lap / Laps to go indicator -->
    <div class="bell-lap-container" id="bell-lap-container">
      <div class="bell-icon" id="bell-lap-icon">&#128276;</div>
      <div class="bell-lap-text" id="bell-lap-text">Bell Lap</div>
    </div>
    
    <!-- Event name below race clock -->
    <div class="event-name" id="event-name">Event Name</div>
    
    <!-- Racer information blocks stacked vertically on bottom-left -->
    <div class="racer-stack" id="racer-stack">
      <!-- Racers will be populated by JavaScript -->
    </div>
    
    <!-- HTML5 Template for racer blocks -->
    <template id="racer-template">
      <div class="racer-block">
        <div class="lane-color"></div>
        <div class="racer-info">
          <div class="racer-name"></div>
          <div class="affiliation"></div>
        </div>
        <div class="time"></div>
        <div class="lap-count"></div>
      </div>
    </template>
    
    <script src="/views/shared/weblynx-helpers.js"></script>
    <script>
      // Configuration - now using externalized view properties
      const UPDATE_INTERVAL = VIEW_CONFIG.updateInterval;
      const SORT_BY = 'place'; // 'place' or 'lane'
      const BELL_LAP_DURATION = (VIEW_CONFIG.bell_lap_duration_seconds || 3) * 1000; // Convert to milliseconds
      // Milestones (laps remaining) at which we show "n Laps to go" or "Bell Lap" (1)
      const LAPS_TO_GO_MILESTONES = [25, 20, 15, 10, 5, 3, 1];
      
      // Track which lap milestones have been shown for this race
      let lapsToGoShown = new Set();
      let lapsToGoTimeout = null;
      
      function getLaneColor(lane) {
        return VIEW_CONFIG.laneColors?.[lane] || VIEW_CONFIG.defaultLaneColor;
      }
      
      
      function createRacerBlock(racer, raceStatus, halfLapModeEnabled) {
        const template = document.getElementById('racer-template');
        const clone = template.content.cloneNode(true);
        
        // Populate the cloned template
        clone.querySelector('.lane-color').style.backgroundColor = getLaneColor(racer.lane);
        clone.querySelector('.racer-name').textContent = racer.name || '-';
        clone.querySelector('.affiliation').textContent = racer.affiliation || '-';
        clone.querySelector('.time').textContent = WebLynx.formatTime(racer.lastSplitTime);
        
        const lapCountElement = clone.querySelector('.lap-count');
        const isHalfLap = racer.delayedLapsRemaining !== null && 
                         racer.delayedLapsRemaining !== undefined && 
                         racer.delayedLapsRemaining % 1 === 0.5 && 
                         (raceStatus === 'NotStarted' || raceStatus === 0);
        
        if (isHalfLap) {
          lapCountElement.innerHTML = WebLynx.formatLapsDisplayHTML(racer.delayedLapsRemaining, raceStatus, halfLapModeEnabled, racer.hasFirstCrossing);
          lapCountElement.classList.add('half-lap');
        } else {
          lapCountElement.textContent = WebLynx.formatLapsDisplay(racer.delayedLapsRemaining, raceStatus, halfLapModeEnabled, racer.hasFirstCrossing);
        }

        return clone;
      }
      
      function showLapsToGo(milestone) {
        const container = document.getElementById('bell-lap-container');
        const iconEl = document.getElementById('bell-lap-icon');
        const textEl = document.getElementById('bell-lap-text');
        if (!container || !textEl) return;
        
        if (milestone === 1) {
          textEl.textContent = 'Bell Lap';
          if (iconEl) iconEl.style.display = '';
        } else {
          textEl.textContent = milestone + ' Laps to go';
          if (iconEl) iconEl.style.display = 'none';
        }
        
        container.classList.add('show');
        if (lapsToGoTimeout) clearTimeout(lapsToGoTimeout);
        lapsToGoTimeout = setTimeout(() => {
          container.classList.remove('show');
        }, BELL_LAP_DURATION);
      }
      
      // Test function - call from console: testLapsToGo(n) e.g. testLapsToGo(1) for Bell Lap, testLapsToGo(5) for "5 Laps to go"
      window.testLapsToGo = function(milestone) {
        lapsToGoShown.clear();
        showLapsToGo(milestone);
      };
      window.testBellLap = function() { window.testLapsToGo(1); };
      
      function positionEventName() {
        const racerStack = document.getElementById('racer-stack');
        const eventName = document.getElementById('event-name');
        const bellLapContainer = document.getElementById('bell-lap-container');
        
        if (racerStack && eventName) {
          const stackRect = racerStack.getBoundingClientRect();
          const eventHeight = 40; // Approximate height of event name box
          const spacing = 4; // Space between event name and racer stack
          
          // Position event name above the racer stack
          eventName.style.position = 'fixed';
          eventName.style.bottom = (window.innerHeight - stackRect.top + spacing) + 'px';
          // Don't set left or width - let CSS handle the positioning
          
          // Position bell lap above event name
          if (bellLapContainer) {
            const eventRect = eventName.getBoundingClientRect();
            const bellLapSpacing = 8; // Space between bell lap and event name
            bellLapContainer.style.position = 'fixed';
            bellLapContainer.style.bottom = (window.innerHeight - eventRect.top + eventRect.height + bellLapSpacing) + 'px';
          }
        }
      }
      
      function updateRaceData() {
        WebLynx.updateRaceData((data, error) => {
          if (error) {
            console.error('Error fetching race data:', error);
            return;
          }
          
          // Check for laps-to-go milestones (25, 20, 15, 10, 5, 3, 1) - first time any racer reaches each
          const isRaceRunning = data.status === 'Running' || data.status === 'Paused' || 
                               data.status === 1 || data.status === 2;
          
          if (isRaceRunning) {
            const activeRacers = WebLynx.getActiveRacers(data.racers);
            let minLapsRemaining = null;
            
            activeRacers.forEach(racer => {
              let realLapsRemaining = null;
              if (racer.lapsRemaining !== undefined && racer.lapsRemaining !== null) {
                realLapsRemaining = racer.lapsRemaining;
              } else if (racer.realLapsRemaining !== undefined && racer.realLapsRemaining !== null) {
                realLapsRemaining = racer.realLapsRemaining;
              } else if (racer.actualLapsRemaining !== undefined && racer.actualLapsRemaining !== null) {
                realLapsRemaining = racer.actualLapsRemaining;
              } else if (racer.delayedLapsRemaining !== undefined && racer.delayedLapsRemaining !== null) {
                realLapsRemaining = racer.delayedLapsRemaining;
              }
              if (realLapsRemaining !== null && (minLapsRemaining === null || realLapsRemaining < minLapsRemaining)) {
                minLapsRemaining = realLapsRemaining;
              }
            });
            
            if (minLapsRemaining !== null) {
              // Find the largest milestone we've crossed that we haven't shown yet
              for (const n of LAPS_TO_GO_MILESTONES) {
                if (minLapsRemaining <= n && !lapsToGoShown.has(n)) {
                  lapsToGoShown.add(n);
                  showLapsToGo(n);
                  break; // Only show one at a time
                }
              }
            }
          }
          
          // Reset laps-to-go state when race ends or resets
          const isRaceEnded = data.status === 'NotStarted' || data.status === 0 || 
                             data.status === 'Finished' || data.status === 3;
          
          if (isRaceEnded) {
            lapsToGoShown.clear();
            const bellLapContainer = document.getElementById('bell-lap-container');
            if (bellLapContainer) {
              bellLapContainer.classList.remove('show');
            }
            if (lapsToGoTimeout) {
              clearTimeout(lapsToGoTimeout);
              lapsToGoTimeout = null;
            }
          }
          
          // Update race clock
          document.getElementById('race-clock').textContent = WebLynx.formatRaceTime(data.currentTime);
          
          // Update event name with event number
          const eventName = data.event?.eventName || 'Event Name';
          const eventNumber = data.event?.eventNumber || '';
          const displayName = eventNumber ? `${eventNumber} - ${eventName}` : eventName;
          document.getElementById('event-name').textContent = displayName;
          
          // Update racer stack
          const racerStack = document.getElementById('racer-stack');
          racerStack.innerHTML = '';
          
          // Only display racers that are actually in the race
          const activeRacers = WebLynx.getActiveRacers(data.racers);
          const halfLapModeEnabled = data.halfLapModeEnabled || false;
          
          // Add racer blocks (2-10 racers supported)
          activeRacers.forEach(racer => {
            racerStack.appendChild(createRacerBlock(racer, data.status, halfLapModeEnabled));
          });
          
          // Position event name above the racer stack
          positionEventName();
        }, SORT_BY);
      }
      
      // Start updating
      WebLynx.startAutoUpdate(updateRaceData, UPDATE_INTERVAL, SORT_BY);
    </script>
  </body>
</html>
