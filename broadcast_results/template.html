<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" type="image/png" href="/views/broadcast_results/sso-logo.png">
    <link rel="stylesheet" href="/views/broadcast_results/styles.css">
    {{VIEW_PROPERTIES}}
  </head>
  <body>
    <div class="broadcast-overlay">
      <!-- Header Section -->
      <div class="header-section">
        <div class="meet-title" id="meet-title">{{MEET_TITLE}}</div>
        <div class="event-name" id="event-name">{{EVENT_SUBTITLE}}</div>
        <div class="unofficial-indicator">{{UNOFFICIAL_RESULTS_TEXT}}</div>
        <div class="sso-logo">
          <img src="/views/broadcast_results/sso-logo.png" alt="SSO Logo" />
        </div>
      </div>
      
      <!-- Race Details Bar -->
      <div class="race-details-bar" id="race-details-bar">
        No active race
      </div>
      
      <!-- Results Table -->
      <div class="results-container" id="results-container">
        <!-- Results will be populated by JavaScript -->
      </div>
    </div>
    
    <!-- HTML5 Template for result rows --> 
    <template id="result-template">
      <div class="result-row">
        <div class="position"></div>
        <div class="racer-info">
          <div class="racer-name"></div>
          <div class="affiliation"></div>
        </div>
        <div class="lane-color"></div>
        <div class="final-time"></div>
      </div>
    </template>
    
    <script src="/views/shared/weblynx-helpers.js"></script>
    <script>
      // Configuration - now using externalized view properties
      const UPDATE_INTERVAL = 1000; // milliseconds - less frequent for results
      
      // TEMPORARY: set to true to always show unofficial banner and demo racers when none loaded
      const DEMO_RESULTS_VIEW = false;
      const DEMO_RACERS = [
        { lane: 1, name: 'Demo Skater One', affiliation: 'Club A', hasPlaceData: true, placeText: '1', finalTime: '00:01:25.3400000', cumulativeSplitTime: '00:01:25.3400000' },
        { lane: 2, name: 'Demo Skater Two', affiliation: 'Club B', hasPlaceData: true, placeText: '2', finalTime: '00:01:26.1200000', cumulativeSplitTime: '00:01:26.1200000' },
        { lane: 3, name: 'Demo Skater Three', affiliation: 'Club A', hasPlaceData: true, placeText: '3', finalTime: '00:01:27.8900000', cumulativeSplitTime: '00:01:27.8900000' },
        { lane: 4, name: 'Demo Skater Four', affiliation: 'Club C', hasPlaceData: true, placeText: '4', finalTime: '00:01:28.4500000', cumulativeSplitTime: '00:01:28.4500000' },
      ];
      
      function getLaneColor(lane) {
        return VIEW_CONFIG.laneColors?.[lane] || VIEW_CONFIG.defaultLaneColor;
      }
      
      
      function createResultRow(racer, hasPlaces) {
        const template = document.getElementById('result-template');
        const clone = template.content.cloneNode(true);
        
        // Populate the cloned template
        const positionElement = clone.querySelector('.position');
        if (racer.hasPlaceData) {
          positionElement.textContent = racer.placeText;
        } else {
          positionElement.textContent = `Lane ${racer.lane}`;
        }
        
        clone.querySelector('.racer-name').textContent = racer.name || '-';
        clone.querySelector('.affiliation').textContent = racer.affiliation || '-';
        clone.querySelector('.lane-color').style.backgroundColor = getLaneColor(racer.lane);
        
        // Set the racer card border to match the lane color
        const resultRow = clone.querySelector('.result-row');
        const laneColor = getLaneColor(racer.lane);
        resultRow.style.border = `2px solid ${laneColor}`;
        
        // Show/hide time box based on whether any racers have places
        // and whether this specific racer has an alpha code (DNF, DNS, etc.)
        const timeElement = clone.querySelector('.final-time');
        const hasAlphaCode = racer.hasPlaceData && WebLynx.isAlphaCode(racer.placeText);
        
        if (hasPlaces && !hasAlphaCode) {
          // Show final time if available, otherwise show cumulative split time
          const timeToShow = racer.finalTime || racer.cumulativeSplitTime;
          timeElement.textContent = WebLynx.formatTime(timeToShow);
          timeElement.style.display = 'block';
        } else {
          timeElement.style.display = 'none';
        }
        
        return clone;
      }
      
      function updateResultsData() {
        WebLynx.updateRaceData((data, error) => {
          if (error) {
            console.error('Error fetching race data:', error);
            return;
          }
          
          // Update meet title and event name if available
          if (data.event) {
            // You might want to customize these based on your data structure
            // For now, using the default values from the template
          }
          
          // Update race details bar
          const allRacers = data.racers ? WebLynx.getActiveRacers(data.racers) : [];
          let sortedRacers = allRacers;
          if (DEMO_RESULTS_VIEW && sortedRacers.length === 0) {
            sortedRacers = DEMO_RACERS;
            document.getElementById('race-details-bar').textContent = 'Demo - Results Preview';
          } else if (data.event) {
            const eventName = data.event.eventName || 'Race Event';
            const eventNumber = data.event.eventNumber || '';
            const raceDetails = eventNumber ? `${eventNumber} - ${eventName}` : eventName;
            document.getElementById('race-details-bar').textContent = raceDetails;
          }
          
          // Update results container
          const resultsContainer = document.getElementById('results-container');
          resultsContainer.innerHTML = '';
          
          // Apply dynamic sizing class based on number of racers
          resultsContainer.className = 'results-container';
          if (sortedRacers.length >= 2 && sortedRacers.length <= 10) {
            resultsContainer.classList.add(`racers-${sortedRacers.length}`);
          }
          
          // Check if any racers have places set
          const hasPlaces = sortedRacers.some(racer => racer.hasPlaceData);
          
          // Show/hide unofficial results indicator (always show when DEMO_RESULTS_VIEW)
          const unofficialIndicator = document.querySelector('.unofficial-indicator');
          if (unofficialIndicator) {
            unofficialIndicator.style.display = (DEMO_RESULTS_VIEW || hasPlaces) ? 'block' : 'none';
          }
          
          // Create result rows
          sortedRacers.forEach(racer => {
            const row = createResultRow(racer, hasPlaces);
            resultsContainer.appendChild(row);
          });
        }, 'place');
      }
      
      // Start updating
      WebLynx.startAutoUpdate(updateResultsData, UPDATE_INTERVAL, 'place');
    </script>
  </body>
</html>
